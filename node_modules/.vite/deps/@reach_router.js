import {
  polyfill,
  require_browser,
  require_warning
} from "./chunk-RLRDOZKC.js";
import {
  require_prop_types
} from "./chunk-5OZKBLEG.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-S2TLTWWO.js";

// node_modules/gud/index.js
var require_gud = __commonJS({
  "node_modules/gud/index.js"(exports, module) {
    "use strict";
    var key = "__global_unique_id__";
    module.exports = function() {
      return global[key] = (global[key] || 0) + 1;
    };
  }
});

// node_modules/@reach/router/node_modules/create-react-context/lib/implementation.js
var require_implementation = __commonJS({
  "node_modules/@reach/router/node_modules/create-react-context/lib/implementation.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = require_prop_types();
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _gud = require_gud();
    var _gud2 = _interopRequireDefault(_gud);
    var _warning = require_warning();
    var _warning2 = _interopRequireDefault(_warning);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn2(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var MAX_SIGNED_31_BIT_INT = 1073741823;
    function objectIs(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function createEventEmitter(value) {
      var handlers = [];
      return {
        on: function on(handler) {
          handlers.push(handler);
        },
        off: function off(handler) {
          handlers = handlers.filter(function(h) {
            return h !== handler;
          });
        },
        get: function get() {
          return value;
        },
        set: function set(newValue, changedBits) {
          value = newValue;
          handlers.forEach(function(handler) {
            return handler(value, changedBits);
          });
        }
      };
    }
    function onlyChild(children) {
      return Array.isArray(children) ? children[0] : children;
    }
    function createReactContext(defaultValue, calculateChangedBits) {
      var _Provider$childContex, _Consumer$contextType;
      var contextProp = "__create-react-context-" + (0, _gud2.default)() + "__";
      var Provider = function(_Component) {
        _inherits2(Provider2, _Component);
        function Provider2() {
          var _temp, _this, _ret;
          _classCallCheck2(this, Provider2);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn2(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp), _possibleConstructorReturn2(_this, _ret);
        }
        Provider2.prototype.getChildContext = function getChildContext() {
          var _ref;
          return _ref = {}, _ref[contextProp] = this.emitter, _ref;
        };
        Provider2.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
          if (this.props.value !== nextProps.value) {
            var oldValue = this.props.value;
            var newValue = nextProps.value;
            var changedBits = void 0;
            if (objectIs(oldValue, newValue)) {
              changedBits = 0;
            } else {
              changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
              if (true) {
                (0, _warning2.default)((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, "calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s", changedBits);
              }
              changedBits |= 0;
              if (changedBits !== 0) {
                this.emitter.set(nextProps.value, changedBits);
              }
            }
          }
        };
        Provider2.prototype.render = function render() {
          return this.props.children;
        };
        return Provider2;
      }(_react.Component);
      Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes2.default.object.isRequired, _Provider$childContex);
      var Consumer = function(_Component2) {
        _inherits2(Consumer2, _Component2);
        function Consumer2() {
          var _temp2, _this2, _ret2;
          _classCallCheck2(this, Consumer2);
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn2(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {
            value: _this2.getValue()
          }, _this2.onUpdate = function(newValue, changedBits) {
            var observedBits = _this2.observedBits | 0;
            if ((observedBits & changedBits) !== 0) {
              _this2.setState({ value: _this2.getValue() });
            }
          }, _temp2), _possibleConstructorReturn2(_this2, _ret2);
        }
        Consumer2.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
          var observedBits = nextProps.observedBits;
          this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
        };
        Consumer2.prototype.componentDidMount = function componentDidMount() {
          if (this.context[contextProp]) {
            this.context[contextProp].on(this.onUpdate);
          }
          var observedBits = this.props.observedBits;
          this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
        };
        Consumer2.prototype.componentWillUnmount = function componentWillUnmount() {
          if (this.context[contextProp]) {
            this.context[contextProp].off(this.onUpdate);
          }
        };
        Consumer2.prototype.getValue = function getValue() {
          if (this.context[contextProp]) {
            return this.context[contextProp].get();
          } else {
            return defaultValue;
          }
        };
        Consumer2.prototype.render = function render() {
          return onlyChild(this.props.children)(this.state.value);
        };
        return Consumer2;
      }(_react.Component);
      Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes2.default.object, _Consumer$contextType);
      return {
        Provider,
        Consumer
      };
    }
    exports.default = createReactContext;
    module.exports = exports["default"];
  }
});

// node_modules/@reach/router/node_modules/create-react-context/lib/index.js
var require_lib = __commonJS({
  "node_modules/@reach/router/node_modules/create-react-context/lib/index.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    var _implementation = require_implementation();
    var _implementation2 = _interopRequireDefault(_implementation);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = _react2.default.createContext || _implementation2.default;
    module.exports = exports["default"];
  }
});

// node_modules/@reach/router/es/index.js
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_invariant2 = __toESM(require_browser());
var import_create_react_context = __toESM(require_lib());

// node_modules/@reach/router/es/lib/utils.js
var import_invariant = __toESM(require_browser());
var startsWith = function startsWith2(string, search) {
  return string.substr(0, search.length) === search;
};
var pick = function pick2(routes, uri) {
  var match3 = void 0;
  var default_ = void 0;
  var _uri$split = uri.split("?"), uriPathname = _uri$split[0];
  var uriSegments = segmentize(uriPathname);
  var isRootUri = uriSegments[0] === "";
  var ranked = rankRoutes(routes);
  for (var i = 0, l = ranked.length; i < l; i++) {
    var missed = false;
    var route = ranked[i].route;
    if (route.default) {
      default_ = {
        route,
        params: {},
        uri
      };
      continue;
    }
    var routeSegments = segmentize(route.path);
    var params = {};
    var max = Math.max(uriSegments.length, routeSegments.length);
    var index = 0;
    for (; index < max; index++) {
      var routeSegment = routeSegments[index];
      var uriSegment = uriSegments[index];
      if (isSplat(routeSegment)) {
        var param = routeSegment.slice(1) || "*";
        params[param] = uriSegments.slice(index).map(decodeURIComponent).join("/");
        break;
      }
      if (uriSegment === void 0) {
        missed = true;
        break;
      }
      var dynamicMatch = paramRe.exec(routeSegment);
      if (dynamicMatch && !isRootUri) {
        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;
        !matchIsNotReserved ? true ? (0, import_invariant.default)(false, '<Router> dynamic segment "' + dynamicMatch[1] + '" is a reserved name. Please use a different name in path "' + route.path + '".') : (0, import_invariant.default)(false) : void 0;
        var value = decodeURIComponent(uriSegment);
        params[dynamicMatch[1]] = value;
      } else if (routeSegment !== uriSegment) {
        missed = true;
        break;
      }
    }
    if (!missed) {
      match3 = {
        route,
        params,
        uri: "/" + uriSegments.slice(0, index).join("/")
      };
      break;
    }
  }
  return match3 || default_ || null;
};
var match = function match2(path, uri) {
  return pick([{ path }], uri);
};
var resolve = function resolve2(to, base) {
  if (startsWith(to, "/")) {
    return to;
  }
  var _to$split = to.split("?"), toPathname = _to$split[0], toQuery = _to$split[1];
  var _base$split = base.split("?"), basePathname = _base$split[0];
  var toSegments = segmentize(toPathname);
  var baseSegments = segmentize(basePathname);
  if (toSegments[0] === "") {
    return addQuery(basePathname, toQuery);
  }
  if (!startsWith(toSegments[0], ".")) {
    var pathname = baseSegments.concat(toSegments).join("/");
    return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
  }
  var allSegments = baseSegments.concat(toSegments);
  var segments = [];
  for (var i = 0, l = allSegments.length; i < l; i++) {
    var segment = allSegments[i];
    if (segment === "..")
      segments.pop();
    else if (segment !== ".")
      segments.push(segment);
  }
  return addQuery("/" + segments.join("/"), toQuery);
};
var insertParams = function insertParams2(path, params) {
  var _path$split = path.split("?"), pathBase = _path$split[0], _path$split$ = _path$split[1], query = _path$split$ === void 0 ? "" : _path$split$;
  var segments = segmentize(pathBase);
  var constructedPath = "/" + segments.map(function(segment) {
    var match3 = paramRe.exec(segment);
    return match3 ? params[match3[1]] : segment;
  }).join("/");
  var _params$location = params.location;
  _params$location = _params$location === void 0 ? {} : _params$location;
  var _params$location$sear = _params$location.search, search = _params$location$sear === void 0 ? "" : _params$location$sear;
  var searchSplit = search.split("?")[1] || "";
  constructedPath = addQuery(constructedPath, query, searchSplit);
  return constructedPath;
};
var validateRedirect = function validateRedirect2(from, to) {
  var filter = function filter2(segment) {
    return isDynamic(segment);
  };
  var fromString = segmentize(from).filter(filter).sort().join("/");
  var toString = segmentize(to).filter(filter).sort().join("/");
  return fromString === toString;
};
var paramRe = /^:(.+)/;
var SEGMENT_POINTS = 4;
var STATIC_POINTS = 3;
var DYNAMIC_POINTS = 2;
var SPLAT_PENALTY = 1;
var ROOT_POINTS = 1;
var isRootSegment = function isRootSegment2(segment) {
  return segment === "";
};
var isDynamic = function isDynamic2(segment) {
  return paramRe.test(segment);
};
var isSplat = function isSplat2(segment) {
  return segment && segment[0] === "*";
};
var rankRoute = function rankRoute2(route, index) {
  var score = route.default ? 0 : segmentize(route.path).reduce(function(score2, segment) {
    score2 += SEGMENT_POINTS;
    if (isRootSegment(segment))
      score2 += ROOT_POINTS;
    else if (isDynamic(segment))
      score2 += DYNAMIC_POINTS;
    else if (isSplat(segment))
      score2 -= SEGMENT_POINTS + SPLAT_PENALTY;
    else
      score2 += STATIC_POINTS;
    return score2;
  }, 0);
  return { route, score, index };
};
var rankRoutes = function rankRoutes2(routes) {
  return routes.map(rankRoute).sort(function(a, b) {
    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;
  });
};
var segmentize = function segmentize2(uri) {
  return uri.replace(/(^\/+|\/+$)/g, "").split("/");
};
var addQuery = function addQuery2(pathname) {
  for (var _len = arguments.length, query = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    query[_key - 1] = arguments[_key];
  }
  query = query.filter(function(q) {
    return q && q.length > 0;
  });
  return pathname + (query && query.length > 0 ? "?" + query.join("&") : "");
};
var reservedNames = ["uri", "path"];
var shallowCompare = function shallowCompare2(obj1, obj2) {
  var obj1Keys = Object.keys(obj1);
  return obj1Keys.length === Object.keys(obj2).length && obj1Keys.every(function(key) {
    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];
  });
};

// node_modules/@reach/router/es/lib/history.js
var _extends = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var getLocation = function getLocation2(source) {
  var _source$location = source.location, search = _source$location.search, hash = _source$location.hash, href = _source$location.href, origin = _source$location.origin, protocol = _source$location.protocol, host = _source$location.host, hostname = _source$location.hostname, port = _source$location.port;
  var pathname = source.location.pathname;
  if (!pathname && href && canUseDOM) {
    var url = new URL(href);
    pathname = url.pathname;
  }
  return {
    pathname: encodeURI(decodeURI(pathname)),
    search,
    hash,
    href,
    origin,
    protocol,
    host,
    hostname,
    port,
    state: source.history.state,
    key: source.history.state && source.history.state.key || "initial"
  };
};
var createHistory = function createHistory2(source, options) {
  var listeners = [];
  var location = getLocation(source);
  var transitioning = false;
  var resolveTransition = function resolveTransition2() {
  };
  return {
    get location() {
      return location;
    },
    get transitioning() {
      return transitioning;
    },
    _onTransitionComplete: function _onTransitionComplete() {
      transitioning = false;
      resolveTransition();
    },
    listen: function listen(listener) {
      listeners.push(listener);
      var popstateListener = function popstateListener2() {
        location = getLocation(source);
        listener({ location, action: "POP" });
      };
      source.addEventListener("popstate", popstateListener);
      return function() {
        source.removeEventListener("popstate", popstateListener);
        listeners = listeners.filter(function(fn) {
          return fn !== listener;
        });
      };
    },
    navigate: function navigate2(to) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, state = _ref.state, _ref$replace = _ref.replace, replace = _ref$replace === void 0 ? false : _ref$replace;
      if (typeof to === "number") {
        source.history.go(to);
      } else {
        state = _extends({}, state, { key: Date.now() + "" });
        try {
          if (transitioning || replace) {
            source.history.replaceState(state, null, to);
          } else {
            source.history.pushState(state, null, to);
          }
        } catch (e) {
          source.location[replace ? "replace" : "assign"](to);
        }
      }
      location = getLocation(source);
      transitioning = true;
      var transition = new Promise(function(res) {
        return resolveTransition = res;
      });
      listeners.forEach(function(listener) {
        return listener({ location, action: "PUSH" });
      });
      return transition;
    }
  };
};
var createMemorySource = function createMemorySource2() {
  var initialPath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "/";
  var searchIndex = initialPath.indexOf("?");
  var initialLocation = {
    pathname: searchIndex > -1 ? initialPath.substr(0, searchIndex) : initialPath,
    search: searchIndex > -1 ? initialPath.substr(searchIndex) : ""
  };
  var index = 0;
  var stack = [initialLocation];
  var states = [null];
  return {
    get location() {
      return stack[index];
    },
    addEventListener: function addEventListener(name, fn) {
    },
    removeEventListener: function removeEventListener(name, fn) {
    },
    history: {
      get entries() {
        return stack;
      },
      get index() {
        return index;
      },
      get state() {
        return states[index];
      },
      pushState: function pushState(state, _, uri) {
        var _uri$split = uri.split("?"), pathname = _uri$split[0], _uri$split$ = _uri$split[1], search = _uri$split$ === void 0 ? "" : _uri$split$;
        index++;
        stack.push({ pathname, search: search.length ? "?" + search : search });
        states.push(state);
      },
      replaceState: function replaceState(state, _, uri) {
        var _uri$split2 = uri.split("?"), pathname = _uri$split2[0], _uri$split2$ = _uri$split2[1], search = _uri$split2$ === void 0 ? "" : _uri$split2$;
        stack[index] = { pathname, search };
        states[index] = state;
      },
      go: function go(to) {
        var newIndex = index + to;
        if (newIndex < 0 || newIndex > states.length - 1) {
          return;
        }
        index = newIndex;
      }
    }
  };
};
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var getSource = function getSource2() {
  return canUseDOM ? window : createMemorySource();
};
var globalHistory = createHistory(getSource());
var navigate = globalHistory.navigate;

// node_modules/@reach/router/es/index.js
var _extends2 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function _objectWithoutProperties(obj, keys) {
  var target = {};
  for (var i in obj) {
    if (keys.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i))
      continue;
    target[i] = obj[i];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var createNamedContext = function createNamedContext2(name, defaultValue) {
  var Ctx = (0, import_create_react_context.default)(defaultValue);
  Ctx.displayName = name;
  return Ctx;
};
var LocationContext = createNamedContext("Location");
var Location = function Location2(_ref) {
  var children = _ref.children;
  return import_react.default.createElement(
    LocationContext.Consumer,
    null,
    function(context) {
      return context ? children(context) : import_react.default.createElement(
        LocationProvider,
        null,
        children
      );
    }
  );
};
var LocationProvider = function(_React$Component) {
  _inherits(LocationProvider2, _React$Component);
  function LocationProvider2() {
    var _temp, _this, _ret;
    _classCallCheck(this, LocationProvider2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      context: _this.getContext(),
      refs: { unlisten: null }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }
  LocationProvider2.prototype.getContext = function getContext() {
    var _props$history = this.props.history, navigate2 = _props$history.navigate, location = _props$history.location;
    return { navigate: navigate2, location };
  };
  LocationProvider2.prototype.componentDidCatch = function componentDidCatch(error, info) {
    if (isRedirect(error)) {
      var _navigate = this.props.history.navigate;
      _navigate(error.uri, { replace: true });
    } else {
      throw error;
    }
  };
  LocationProvider2.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevState.context.location !== this.state.context.location) {
      this.props.history._onTransitionComplete();
    }
  };
  LocationProvider2.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;
    var refs = this.state.refs, history = this.props.history;
    history._onTransitionComplete();
    refs.unlisten = history.listen(function() {
      Promise.resolve().then(function() {
        requestAnimationFrame(function() {
          if (!_this2.unmounted) {
            _this2.setState(function() {
              return { context: _this2.getContext() };
            });
          }
        });
      });
    });
  };
  LocationProvider2.prototype.componentWillUnmount = function componentWillUnmount() {
    var refs = this.state.refs;
    this.unmounted = true;
    refs.unlisten();
  };
  LocationProvider2.prototype.render = function render() {
    var context = this.state.context, children = this.props.children;
    return import_react.default.createElement(
      LocationContext.Provider,
      { value: context },
      typeof children === "function" ? children(context) : children || null
    );
  };
  return LocationProvider2;
}(import_react.default.Component);
LocationProvider.defaultProps = {
  history: globalHistory
};
true ? LocationProvider.propTypes = {
  history: import_prop_types.default.object.isRequired
} : void 0;
var ServerLocation = function ServerLocation2(_ref2) {
  var url = _ref2.url, children = _ref2.children;
  var searchIndex = url.indexOf("?");
  var searchExists = searchIndex > -1;
  var pathname = void 0;
  var search = "";
  var hash = "";
  if (searchExists) {
    pathname = url.substring(0, searchIndex);
    search = url.substring(searchIndex);
  } else {
    pathname = url;
  }
  return import_react.default.createElement(
    LocationContext.Provider,
    {
      value: {
        location: {
          pathname,
          search,
          hash
        },
        navigate: function navigate2() {
          throw new Error("You can't call navigate on the server.");
        }
      }
    },
    children
  );
};
var BaseContext = createNamedContext("Base", { baseuri: "/", basepath: "/" });
var Router = function Router2(props) {
  return import_react.default.createElement(
    BaseContext.Consumer,
    null,
    function(baseContext) {
      return import_react.default.createElement(
        Location,
        null,
        function(locationContext) {
          return import_react.default.createElement(RouterImpl, _extends2({}, baseContext, locationContext, props));
        }
      );
    }
  );
};
var RouterImpl = function(_React$PureComponent) {
  _inherits(RouterImpl2, _React$PureComponent);
  function RouterImpl2() {
    _classCallCheck(this, RouterImpl2);
    return _possibleConstructorReturn(this, _React$PureComponent.apply(this, arguments));
  }
  RouterImpl2.prototype.render = function render() {
    var _props = this.props, location = _props.location, _navigate2 = _props.navigate, basepath = _props.basepath, primary = _props.primary, children = _props.children, baseuri = _props.baseuri, _props$component = _props.component, component = _props$component === void 0 ? "div" : _props$component, domProps = _objectWithoutProperties(_props, ["location", "navigate", "basepath", "primary", "children", "baseuri", "component"]);
    var routes = import_react.default.Children.toArray(children).reduce(function(array, child) {
      var routes2 = createRoute(basepath)(child);
      return array.concat(routes2);
    }, []);
    var pathname = location.pathname;
    var match3 = pick(routes, pathname);
    if (match3) {
      var params = match3.params, uri = match3.uri, route = match3.route, element = match3.route.value;
      basepath = route.default ? basepath : route.path.replace(/\*$/, "");
      var props = _extends2({}, params, {
        uri,
        location,
        navigate: function navigate2(to, options) {
          return _navigate2(resolve(to, uri), options);
        }
      });
      var clone = import_react.default.cloneElement(element, props, element.props.children ? import_react.default.createElement(
        Router,
        { location, primary },
        element.props.children
      ) : void 0);
      var FocusWrapper = primary ? FocusHandler : component;
      var wrapperProps = primary ? _extends2({ uri, location, component }, domProps) : domProps;
      return import_react.default.createElement(
        BaseContext.Provider,
        { value: { baseuri: uri, basepath } },
        import_react.default.createElement(
          FocusWrapper,
          wrapperProps,
          clone
        )
      );
    } else {
      return null;
    }
  };
  return RouterImpl2;
}(import_react.default.PureComponent);
RouterImpl.defaultProps = {
  primary: true
};
var FocusContext = createNamedContext("Focus");
var FocusHandler = function FocusHandler2(_ref3) {
  var uri = _ref3.uri, location = _ref3.location, component = _ref3.component, domProps = _objectWithoutProperties(_ref3, ["uri", "location", "component"]);
  return import_react.default.createElement(
    FocusContext.Consumer,
    null,
    function(requestFocus) {
      return import_react.default.createElement(FocusHandlerImpl, _extends2({}, domProps, {
        component,
        requestFocus,
        uri,
        location
      }));
    }
  );
};
var initialRender = true;
var focusHandlerCount = 0;
var FocusHandlerImpl = function(_React$Component2) {
  _inherits(FocusHandlerImpl2, _React$Component2);
  function FocusHandlerImpl2() {
    var _temp2, _this4, _ret2;
    _classCallCheck(this, FocusHandlerImpl2);
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return _ret2 = (_temp2 = (_this4 = _possibleConstructorReturn(this, _React$Component2.call.apply(_React$Component2, [this].concat(args))), _this4), _this4.state = {}, _this4.requestFocus = function(node) {
      if (!_this4.state.shouldFocus && node) {
        node.focus();
      }
    }, _temp2), _possibleConstructorReturn(_this4, _ret2);
  }
  FocusHandlerImpl2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    var initial = prevState.uri == null;
    if (initial) {
      return _extends2({
        shouldFocus: true
      }, nextProps);
    } else {
      var myURIChanged = nextProps.uri !== prevState.uri;
      var navigatedUpToMe = prevState.location.pathname !== nextProps.location.pathname && nextProps.location.pathname === nextProps.uri;
      return _extends2({
        shouldFocus: myURIChanged || navigatedUpToMe
      }, nextProps);
    }
  };
  FocusHandlerImpl2.prototype.componentDidMount = function componentDidMount() {
    focusHandlerCount++;
    this.focus();
  };
  FocusHandlerImpl2.prototype.componentWillUnmount = function componentWillUnmount() {
    focusHandlerCount--;
    if (focusHandlerCount === 0) {
      initialRender = true;
    }
  };
  FocusHandlerImpl2.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevProps.location !== this.props.location && this.state.shouldFocus) {
      this.focus();
    }
  };
  FocusHandlerImpl2.prototype.focus = function focus() {
    if (false) {
      return;
    }
    var requestFocus = this.props.requestFocus;
    if (requestFocus) {
      requestFocus(this.node);
    } else {
      if (initialRender) {
        initialRender = false;
      } else if (this.node) {
        if (!this.node.contains(document.activeElement)) {
          this.node.focus();
        }
      }
    }
  };
  FocusHandlerImpl2.prototype.render = function render() {
    var _this5 = this;
    var _props2 = this.props, children = _props2.children, style = _props2.style, requestFocus = _props2.requestFocus, _props2$component = _props2.component, Comp = _props2$component === void 0 ? "div" : _props2$component, uri = _props2.uri, location = _props2.location, domProps = _objectWithoutProperties(_props2, ["children", "style", "requestFocus", "component", "uri", "location"]);
    return import_react.default.createElement(
      Comp,
      _extends2({
        style: _extends2({ outline: "none" }, style),
        tabIndex: "-1",
        ref: function ref(n) {
          return _this5.node = n;
        }
      }, domProps),
      import_react.default.createElement(
        FocusContext.Provider,
        { value: this.requestFocus },
        this.props.children
      )
    );
  };
  return FocusHandlerImpl2;
}(import_react.default.Component);
polyfill(FocusHandlerImpl);
var k = function k2() {
};
var forwardRef = import_react.default.forwardRef;
if (typeof forwardRef === "undefined") {
  forwardRef = function forwardRef2(C) {
    return C;
  };
}
var Link = forwardRef(function(_ref4, ref) {
  var innerRef = _ref4.innerRef, props = _objectWithoutProperties(_ref4, ["innerRef"]);
  return import_react.default.createElement(
    BaseContext.Consumer,
    null,
    function(_ref5) {
      var basepath = _ref5.basepath, baseuri = _ref5.baseuri;
      return import_react.default.createElement(
        Location,
        null,
        function(_ref6) {
          var location = _ref6.location, navigate2 = _ref6.navigate;
          var to = props.to, state = props.state, replace = props.replace, _props$getProps = props.getProps, getProps = _props$getProps === void 0 ? k : _props$getProps, anchorProps = _objectWithoutProperties(props, ["to", "state", "replace", "getProps"]);
          var href = resolve(to, baseuri);
          var encodedHref = encodeURI(href);
          var isCurrent = location.pathname === encodedHref;
          var isPartiallyCurrent = startsWith(location.pathname, encodedHref);
          return import_react.default.createElement("a", _extends2({
            ref: ref || innerRef,
            "aria-current": isCurrent ? "page" : void 0
          }, anchorProps, getProps({ isCurrent, isPartiallyCurrent, href, location }), {
            href,
            onClick: function onClick(event) {
              if (anchorProps.onClick)
                anchorProps.onClick(event);
              if (shouldNavigate(event)) {
                event.preventDefault();
                var shouldReplace = replace;
                if (typeof replace !== "boolean" && isCurrent) {
                  var _location$state = _extends2({}, location.state), key = _location$state.key, restState = _objectWithoutProperties(_location$state, ["key"]);
                  shouldReplace = shallowCompare(_extends2({}, state), restState);
                }
                navigate2(href, {
                  state,
                  replace: shouldReplace
                });
              }
            }
          }));
        }
      );
    }
  );
});
Link.displayName = "Link";
true ? Link.propTypes = {
  to: import_prop_types.default.string.isRequired
} : void 0;
function RedirectRequest(uri) {
  this.uri = uri;
}
var isRedirect = function isRedirect2(o) {
  return o instanceof RedirectRequest;
};
var redirectTo = function redirectTo2(to) {
  throw new RedirectRequest(to);
};
var RedirectImpl = function(_React$Component3) {
  _inherits(RedirectImpl2, _React$Component3);
  function RedirectImpl2() {
    _classCallCheck(this, RedirectImpl2);
    return _possibleConstructorReturn(this, _React$Component3.apply(this, arguments));
  }
  RedirectImpl2.prototype.componentDidMount = function componentDidMount() {
    var _props3 = this.props, navigate2 = _props3.navigate, to = _props3.to, from = _props3.from, _props3$replace = _props3.replace, replace = _props3$replace === void 0 ? true : _props3$replace, state = _props3.state, noThrow = _props3.noThrow, baseuri = _props3.baseuri, props = _objectWithoutProperties(_props3, ["navigate", "to", "from", "replace", "state", "noThrow", "baseuri"]);
    Promise.resolve().then(function() {
      var resolvedTo = resolve(to, baseuri);
      navigate2(insertParams(resolvedTo, props), { replace, state });
    });
  };
  RedirectImpl2.prototype.render = function render() {
    var _props4 = this.props, navigate2 = _props4.navigate, to = _props4.to, from = _props4.from, replace = _props4.replace, state = _props4.state, noThrow = _props4.noThrow, baseuri = _props4.baseuri, props = _objectWithoutProperties(_props4, ["navigate", "to", "from", "replace", "state", "noThrow", "baseuri"]);
    var resolvedTo = resolve(to, baseuri);
    if (!noThrow)
      redirectTo(insertParams(resolvedTo, props));
    return null;
  };
  return RedirectImpl2;
}(import_react.default.Component);
var Redirect = function Redirect2(props) {
  return import_react.default.createElement(
    BaseContext.Consumer,
    null,
    function(_ref7) {
      var baseuri = _ref7.baseuri;
      return import_react.default.createElement(
        Location,
        null,
        function(locationContext) {
          return import_react.default.createElement(RedirectImpl, _extends2({}, locationContext, { baseuri }, props));
        }
      );
    }
  );
};
true ? Redirect.propTypes = {
  from: import_prop_types.default.string,
  to: import_prop_types.default.string.isRequired
} : void 0;
var Match = function Match2(_ref8) {
  var path = _ref8.path, children = _ref8.children;
  return import_react.default.createElement(
    BaseContext.Consumer,
    null,
    function(_ref9) {
      var baseuri = _ref9.baseuri;
      return import_react.default.createElement(
        Location,
        null,
        function(_ref10) {
          var navigate2 = _ref10.navigate, location = _ref10.location;
          var resolvedPath = resolve(path, baseuri);
          var result = match(resolvedPath, location.pathname);
          return children({
            navigate: navigate2,
            location,
            match: result ? _extends2({}, result.params, {
              uri: result.uri,
              path
            }) : null
          });
        }
      );
    }
  );
};
var useLocation = function useLocation2() {
  var context = (0, import_react.useContext)(LocationContext);
  if (!context) {
    throw new Error("useLocation hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router");
  }
  return context.location;
};
var useNavigate = function useNavigate2() {
  var context = (0, import_react.useContext)(LocationContext);
  if (!context) {
    throw new Error("useNavigate hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router");
  }
  return context.navigate;
};
var useParams = function useParams2() {
  var context = (0, import_react.useContext)(BaseContext);
  if (!context) {
    throw new Error("useParams hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router");
  }
  var location = useLocation();
  var results = match(context.basepath, location.pathname);
  return results ? results.params : null;
};
var useMatch = function useMatch2(path) {
  if (!path) {
    throw new Error("useMatch(path: string) requires an argument of a string to match against");
  }
  var context = (0, import_react.useContext)(BaseContext);
  if (!context) {
    throw new Error("useMatch hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router");
  }
  var location = useLocation();
  var resolvedPath = resolve(path, context.baseuri);
  var result = match(resolvedPath, location.pathname);
  return result ? _extends2({}, result.params, {
    uri: result.uri,
    path
  }) : null;
};
var stripSlashes = function stripSlashes2(str) {
  return str.replace(/(^\/+|\/+$)/g, "");
};
var createRoute = function createRoute2(basepath) {
  return function(element) {
    if (!element) {
      return null;
    }
    if (element.type === import_react.default.Fragment && element.props.children) {
      return import_react.default.Children.map(element.props.children, createRoute2(basepath));
    }
    !(element.props.path || element.props.default || element.type === Redirect) ? true ? (0, import_invariant2.default)(false, "<Router>: Children of <Router> must have a `path` or `default` prop, or be a `<Redirect>`. None found on element type `" + element.type + "`") : (0, import_invariant2.default)(false) : void 0;
    !!(element.type === Redirect && (!element.props.from || !element.props.to)) ? true ? (0, import_invariant2.default)(false, '<Redirect from="' + element.props.from + '" to="' + element.props.to + '"/> requires both "from" and "to" props when inside a <Router>.') : (0, import_invariant2.default)(false) : void 0;
    !!(element.type === Redirect && !validateRedirect(element.props.from, element.props.to)) ? true ? (0, import_invariant2.default)(false, '<Redirect from="' + element.props.from + ' to="' + element.props.to + '"/> has mismatched dynamic segments, ensure both paths have the exact same dynamic segments.') : (0, import_invariant2.default)(false) : void 0;
    if (element.props.default) {
      return { value: element, default: true };
    }
    var elementPath = element.type === Redirect ? element.props.from : element.props.path;
    var path = elementPath === "/" ? basepath : stripSlashes(basepath) + "/" + stripSlashes(elementPath);
    return {
      value: element,
      default: element.props.default,
      path: element.props.children ? stripSlashes(path) + "/*" : path
    };
  };
};
var shouldNavigate = function shouldNavigate2(event) {
  return !event.defaultPrevented && event.button === 0 && !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};
export {
  Link,
  Location,
  LocationProvider,
  Match,
  Redirect,
  Router,
  ServerLocation,
  createHistory,
  createMemorySource,
  globalHistory,
  isRedirect,
  match as matchPath,
  navigate,
  redirectTo,
  useLocation,
  useMatch,
  useNavigate,
  useParams
};
//# sourceMappingURL=@reach_router.js.map
